/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface LiquidityPoolInterface extends ethers.utils.Interface {
  functions: {
    "addLiquidity(int256)": FunctionFragment;
    "adjustPerpetualRiskParameter(uint256,bytes32,int256)": FunctionFragment;
    "brokerTrade(tuple,int256,bytes)": FunctionFragment;
    "claimFee(int256)": FunctionFragment;
    "claimableFee(address)": FunctionFragment;
    "clear(uint256)": FunctionFragment;
    "clearProgress(uint256)": FunctionFragment;
    "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])": FunctionFragment;
    "deposit(uint256,address,int256)": FunctionFragment;
    "donateInsuranceFund(int256)": FunctionFragment;
    "finalize()": FunctionFragment;
    "initialize(address,address,address,address)": FunctionFragment;
    "liquidateByAMM(uint256,address,uint256)": FunctionFragment;
    "liquidateByTrader(uint256,address,int256,int256,uint256)": FunctionFragment;
    "liquidityPoolInfo()": FunctionFragment;
    "marginAccount(uint256,address)": FunctionFragment;
    "perpetualInfo(uint256)": FunctionFragment;
    "removeLiquidity(int256)": FunctionFragment;
    "settle(uint256,address)": FunctionFragment;
    "settleableMargin(uint256,address)": FunctionFragment;
    "trade(uint256,address,int256,int256,uint256,address,bool)": FunctionFragment;
    "updateLiquidityPoolParameter(bytes32,int256)": FunctionFragment;
    "updatePerpetualParameter(uint256,bytes32,int256)": FunctionFragment;
    "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)": FunctionFragment;
    "withdraw(uint256,address,int256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addLiquidity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "adjustPerpetualRiskParameter",
    values: [BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "brokerTrade",
    values: [
      {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimableFee",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "clear", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "clearProgress",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createPerpetual",
    values: [
      string,
      [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "donateInsuranceFund",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "finalize", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateByAMM",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateByTrader",
    values: [BigNumberish, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityPoolInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marginAccount",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "perpetualInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settle",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "settleableMargin",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "trade",
    values: [
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateLiquidityPoolParameter",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePerpetualParameter",
    values: [BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePerpetualRiskParameter",
    values: [BigNumberish, BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish, string, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "adjustPerpetualRiskParameter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "brokerTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimableFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "clear", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "clearProgress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPerpetual",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "donateInsuranceFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finalize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "liquidateByAMM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateByTrader",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidityPoolInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marginAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "perpetualInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "settleableMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "trade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateLiquidityPoolParameter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePerpetualParameter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePerpetualRiskParameter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "AddLiquidity(address,int256,int256)": EventFragment;
    "AdjustPerpetualRiskSetting(uint256,bytes32,int256)": EventFragment;
    "ClaimFee(address,int256)": EventFragment;
    "ClearAccount(uint256,address)": EventFragment;
    "CreatePerpetual(uint256,address,address,address,address,address,int256[8],int256[5])": EventFragment;
    "Deposit(uint256,address,int256)": EventFragment;
    "DonateInsuranceFund(address,int256)": EventFragment;
    "Finalize()": EventFragment;
    "Liquidate(uint256,address,address,int256,int256)": EventFragment;
    "RemoveLiquidity(address,int256,int256)": EventFragment;
    "SettleAccount(uint256,address,int256)": EventFragment;
    "Trade(uint256,address,int256,int256,int256)": EventFragment;
    "UpdateLiquidityPoolParameter(bytes32,int256)": EventFragment;
    "UpdatePerpetualParameter(uint256,bytes32,int256)": EventFragment;
    "UpdatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)": EventFragment;
    "Withdraw(uint256,address,int256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddLiquidity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AdjustPerpetualRiskSetting"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClearAccount"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatePerpetual"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DonateInsuranceFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Finalize"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Liquidate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveLiquidity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SettleAccount"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Trade"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateLiquidityPoolParameter"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatePerpetualParameter"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdatePerpetualRiskParameter"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export class LiquidityPool extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: LiquidityPoolInterface;

  functions: {
    addLiquidity(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "addLiquidity(int256)"(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    adjustPerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "adjustPerpetualRiskParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    brokerTrade(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "brokerTrade(tuple,int256,bytes)"(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    claimFee(
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "claimFee(int256)"(
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    claimableFee(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "claimableFee(address)"(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    clear(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "clear(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    clearProgress(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      left: BigNumber;
      total: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "clearProgress(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      left: BigNumber;
      total: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    createPerpetual(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])"(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    deposit(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "deposit(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    donateInsuranceFund(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "donateInsuranceFund(int256)"(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    finalize(overrides?: Overrides): Promise<ContractTransaction>;

    "finalize()"(overrides?: Overrides): Promise<ContractTransaction>;

    initialize(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "initialize(address,address,address,address)"(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    liquidateByAMM(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "liquidateByAMM(uint256,address,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    liquidateByTrader(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "liquidateByTrader(uint256,address,int256,int256,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    liquidityPoolInfo(
      overrides?: CallOverrides
    ): Promise<{
      addresses: [string, string, string, string, string, string];
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      perpetualCount: BigNumber;
      fundingTime: BigNumber;
      0: [string, string, string, string, string, string];
      1: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      2: BigNumber;
      3: BigNumber;
    }>;

    "liquidityPoolInfo()"(
      overrides?: CallOverrides
    ): Promise<{
      addresses: [string, string, string, string, string, string];
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      perpetualCount: BigNumber;
      fundingTime: BigNumber;
      0: [string, string, string, string, string, string];
      1: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      2: BigNumber;
      3: BigNumber;
    }>;

    marginAccount(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<{
      cashBalance: BigNumber;
      positionAmount: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "marginAccount(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<{
      cashBalance: BigNumber;
      positionAmount: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    perpetualInfo(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "perpetualInfo(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeLiquidity(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeLiquidity(int256)"(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    settle(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "settle(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    settleableMargin(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "settleableMargin(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    trade(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "trade(uint256,address,int256,int256,uint256,address,bool)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    updateLiquidityPoolParameter(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateLiquidityPoolParameter(bytes32,int256)"(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    updatePerpetualParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updatePerpetualParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    updatePerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    withdraw(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "withdraw(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  addLiquidity(
    cashToAdd: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "addLiquidity(int256)"(
    cashToAdd: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  adjustPerpetualRiskParameter(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "adjustPerpetualRiskParameter(uint256,bytes32,int256)"(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  brokerTrade(
    order: {
      trader: string;
      broker: string;
      relayer: string;
      referrer: string;
      liquidityPool: string;
      minTradeAmount: BigNumberish;
      amount: BigNumberish;
      limitPrice: BigNumberish;
      triggerPrice: BigNumberish;
      chainID: BigNumberish;
      expiredAt: BigNumberish;
      perpetualIndex: BigNumberish;
      brokerFeeLimit: BigNumberish;
      flags: BigNumberish;
      salt: BigNumberish;
    },
    amount: BigNumberish,
    signature: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "brokerTrade(tuple,int256,bytes)"(
    order: {
      trader: string;
      broker: string;
      relayer: string;
      referrer: string;
      liquidityPool: string;
      minTradeAmount: BigNumberish;
      amount: BigNumberish;
      limitPrice: BigNumberish;
      triggerPrice: BigNumberish;
      chainID: BigNumberish;
      expiredAt: BigNumberish;
      perpetualIndex: BigNumberish;
      brokerFeeLimit: BigNumberish;
      flags: BigNumberish;
      salt: BigNumberish;
    },
    amount: BigNumberish,
    signature: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  claimFee(
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "claimFee(int256)"(
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  claimableFee(claimer: string, overrides?: CallOverrides): Promise<BigNumber>;

  "claimableFee(address)"(
    claimer: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  clear(
    perpetualIndex: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "clear(uint256)"(
    perpetualIndex: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  clearProgress(
    perpetualIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    left: BigNumber;
    total: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  "clearProgress(uint256)"(
    perpetualIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    left: BigNumber;
    total: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  createPerpetual(
    oracle: string,
    coreParams: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    riskParams: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    minRiskParamValues: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    maxRiskParamValues: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])"(
    oracle: string,
    coreParams: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    riskParams: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    minRiskParamValues: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    maxRiskParamValues: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  deposit(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "deposit(uint256,address,int256)"(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  donateInsuranceFund(
    amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "donateInsuranceFund(int256)"(
    amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  finalize(overrides?: Overrides): Promise<ContractTransaction>;

  "finalize()"(overrides?: Overrides): Promise<ContractTransaction>;

  initialize(
    operator: string,
    collateral: string,
    governor: string,
    shareToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "initialize(address,address,address,address)"(
    operator: string,
    collateral: string,
    governor: string,
    shareToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  liquidateByAMM(
    perpetualIndex: BigNumberish,
    trader: string,
    deadline: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "liquidateByAMM(uint256,address,uint256)"(
    perpetualIndex: BigNumberish,
    trader: string,
    deadline: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  liquidateByTrader(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    limitPrice: BigNumberish,
    deadline: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "liquidateByTrader(uint256,address,int256,int256,uint256)"(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    limitPrice: BigNumberish,
    deadline: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  liquidityPoolInfo(
    overrides?: CallOverrides
  ): Promise<{
    addresses: [string, string, string, string, string, string];
    nums: [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ];
    perpetualCount: BigNumber;
    fundingTime: BigNumber;
    0: [string, string, string, string, string, string];
    1: [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ];
    2: BigNumber;
    3: BigNumber;
  }>;

  "liquidityPoolInfo()"(
    overrides?: CallOverrides
  ): Promise<{
    addresses: [string, string, string, string, string, string];
    nums: [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ];
    perpetualCount: BigNumber;
    fundingTime: BigNumber;
    0: [string, string, string, string, string, string];
    1: [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ];
    2: BigNumber;
    3: BigNumber;
  }>;

  marginAccount(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: CallOverrides
  ): Promise<{
    cashBalance: BigNumber;
    positionAmount: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  "marginAccount(uint256,address)"(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: CallOverrides
  ): Promise<{
    cashBalance: BigNumber;
    positionAmount: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  perpetualInfo(
    perpetualIndex: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "perpetualInfo(uint256)"(
    perpetualIndex: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeLiquidity(
    shareToRemove: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeLiquidity(int256)"(
    shareToRemove: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  settle(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "settle(uint256,address)"(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  settleableMargin(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "settleableMargin(uint256,address)"(
    perpetualIndex: BigNumberish,
    trader: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  trade(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    limitPrice: BigNumberish,
    deadline: BigNumberish,
    referrer: string,
    isCloseOnly: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "trade(uint256,address,int256,int256,uint256,address,bool)"(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    limitPrice: BigNumberish,
    deadline: BigNumberish,
    referrer: string,
    isCloseOnly: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  updateLiquidityPoolParameter(
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateLiquidityPoolParameter(bytes32,int256)"(
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  updatePerpetualParameter(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updatePerpetualParameter(uint256,bytes32,int256)"(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  updatePerpetualRiskParameter(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    minValue: BigNumberish,
    maxValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)"(
    perpetualIndex: BigNumberish,
    key: BytesLike,
    newValue: BigNumberish,
    minValue: BigNumberish,
    maxValue: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  withdraw(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "withdraw(uint256,address,int256)"(
    perpetualIndex: BigNumberish,
    trader: string,
    amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    addLiquidity(
      cashToAdd: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "addLiquidity(int256)"(
      cashToAdd: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    adjustPerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "adjustPerpetualRiskParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    brokerTrade(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "brokerTrade(tuple,int256,bytes)"(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    claimFee(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    "claimFee(int256)"(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    claimableFee(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimableFee(address)"(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    clear(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "clear(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    clearProgress(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      left: BigNumber;
      total: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "clearProgress(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      left: BigNumber;
      total: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    createPerpetual(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])"(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    donateInsuranceFund(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "donateInsuranceFund(int256)"(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    finalize(overrides?: CallOverrides): Promise<void>;

    "finalize()"(overrides?: CallOverrides): Promise<void>;

    initialize(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "initialize(address,address,address,address)"(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidateByAMM(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "liquidateByAMM(uint256,address,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidateByTrader(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "liquidateByTrader(uint256,address,int256,int256,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidityPoolInfo(
      overrides?: CallOverrides
    ): Promise<{
      addresses: [string, string, string, string, string, string];
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      perpetualCount: BigNumber;
      fundingTime: BigNumber;
      0: [string, string, string, string, string, string];
      1: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      2: BigNumber;
      3: BigNumber;
    }>;

    "liquidityPoolInfo()"(
      overrides?: CallOverrides
    ): Promise<{
      addresses: [string, string, string, string, string, string];
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      perpetualCount: BigNumber;
      fundingTime: BigNumber;
      0: [string, string, string, string, string, string];
      1: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      2: BigNumber;
      3: BigNumber;
    }>;

    marginAccount(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<{
      cashBalance: BigNumber;
      positionAmount: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    "marginAccount(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<{
      cashBalance: BigNumber;
      positionAmount: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    perpetualInfo(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      state: number;
      oracle: string;
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      0: number;
      1: string;
      2: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
    }>;

    "perpetualInfo(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      state: number;
      oracle: string;
      nums: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
      0: number;
      1: string;
      2: [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ];
    }>;

    removeLiquidity(
      shareToRemove: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeLiquidity(int256)"(
      shareToRemove: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    settle(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "settle(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<void>;

    settleableMargin(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "settleableMargin(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    trade(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "trade(uint256,address,int256,int256,uint256,address,bool)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    updateLiquidityPoolParameter(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "updateLiquidityPoolParameter(bytes32,int256)"(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePerpetualParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "updatePerpetualParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    AddLiquidity(trader: null, addedCash: null, mintedShare: null): EventFilter;

    AdjustPerpetualRiskSetting(
      perpetualIndex: null,
      key: null,
      value: null
    ): EventFilter;

    ClaimFee(claimer: null, amount: null): EventFilter;

    ClearAccount(perpetualIndex: null, trader: null): EventFilter;

    CreatePerpetual(
      perpetualIndex: null,
      governor: null,
      shareToken: null,
      operator: null,
      oracle: null,
      collateral: null,
      coreParams: null,
      riskParams: null
    ): EventFilter;

    Deposit(perpetualIndex: null, trader: null, amount: null): EventFilter;

    DonateInsuranceFund(trader: null, amount: null): EventFilter;

    Finalize(): EventFilter;

    Liquidate(
      perpetualIndex: null,
      liquidator: string | null,
      trader: string | null,
      amount: null,
      price: null
    ): EventFilter;

    RemoveLiquidity(
      trader: null,
      returnedCash: null,
      burnedShare: null
    ): EventFilter;

    SettleAccount(
      perpetualIndex: null,
      trader: null,
      amount: null
    ): EventFilter;

    Trade(
      perpetualIndex: null,
      trader: string | null,
      positionAmount: null,
      price: null,
      fee: null
    ): EventFilter;

    UpdateLiquidityPoolParameter(key: null, value: null): EventFilter;

    UpdatePerpetualParameter(
      perpetualIndex: null,
      key: null,
      value: null
    ): EventFilter;

    UpdatePerpetualRiskParameter(
      perpetualIndex: null,
      key: null,
      value: null,
      minValue: null,
      maxValue: null
    ): EventFilter;

    Withdraw(perpetualIndex: null, trader: null, amount: null): EventFilter;
  };

  estimateGas: {
    addLiquidity(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "addLiquidity(int256)"(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    adjustPerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "adjustPerpetualRiskParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    brokerTrade(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "brokerTrade(tuple,int256,bytes)"(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    claimFee(amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

    "claimFee(int256)"(
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    claimableFee(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimableFee(address)"(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    clear(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "clear(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    clearProgress(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "clearProgress(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createPerpetual(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])"(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<BigNumber>;

    deposit(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "deposit(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    donateInsuranceFund(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "donateInsuranceFund(int256)"(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    finalize(overrides?: Overrides): Promise<BigNumber>;

    "finalize()"(overrides?: Overrides): Promise<BigNumber>;

    initialize(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "initialize(address,address,address,address)"(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    liquidateByAMM(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "liquidateByAMM(uint256,address,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    liquidateByTrader(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "liquidateByTrader(uint256,address,int256,int256,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    liquidityPoolInfo(overrides?: CallOverrides): Promise<BigNumber>;

    "liquidityPoolInfo()"(overrides?: CallOverrides): Promise<BigNumber>;

    marginAccount(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "marginAccount(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    perpetualInfo(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "perpetualInfo(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeLiquidity(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeLiquidity(int256)"(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    settle(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "settle(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    settleableMargin(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "settleableMargin(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    trade(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "trade(uint256,address,int256,int256,uint256,address,bool)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    updateLiquidityPoolParameter(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateLiquidityPoolParameter(bytes32,int256)"(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    updatePerpetualParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updatePerpetualParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    updatePerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    withdraw(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "withdraw(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidity(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "addLiquidity(int256)"(
      cashToAdd: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    adjustPerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "adjustPerpetualRiskParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    brokerTrade(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "brokerTrade(tuple,int256,bytes)"(
      order: {
        trader: string;
        broker: string;
        relayer: string;
        referrer: string;
        liquidityPool: string;
        minTradeAmount: BigNumberish;
        amount: BigNumberish;
        limitPrice: BigNumberish;
        triggerPrice: BigNumberish;
        chainID: BigNumberish;
        expiredAt: BigNumberish;
        perpetualIndex: BigNumberish;
        brokerFeeLimit: BigNumberish;
        flags: BigNumberish;
        salt: BigNumberish;
      },
      amount: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    claimFee(
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "claimFee(int256)"(
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    claimableFee(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimableFee(address)"(
      claimer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    clear(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "clear(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    clearProgress(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "clearProgress(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createPerpetual(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "createPerpetual(address,int256[8],int256[5],int256[5],int256[5])"(
      oracle: string,
      coreParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      riskParams: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      minRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      maxRiskParamValues: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    deposit(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "deposit(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    donateInsuranceFund(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "donateInsuranceFund(int256)"(
      amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    finalize(overrides?: Overrides): Promise<PopulatedTransaction>;

    "finalize()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    initialize(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "initialize(address,address,address,address)"(
      operator: string,
      collateral: string,
      governor: string,
      shareToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    liquidateByAMM(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "liquidateByAMM(uint256,address,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    liquidateByTrader(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "liquidateByTrader(uint256,address,int256,int256,uint256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    liquidityPoolInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "liquidityPoolInfo()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marginAccount(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "marginAccount(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    perpetualInfo(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "perpetualInfo(uint256)"(
      perpetualIndex: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeLiquidity(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeLiquidity(int256)"(
      shareToRemove: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    settle(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "settle(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    settleableMargin(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "settleableMargin(uint256,address)"(
      perpetualIndex: BigNumberish,
      trader: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    trade(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "trade(uint256,address,int256,int256,uint256,address,bool)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      limitPrice: BigNumberish,
      deadline: BigNumberish,
      referrer: string,
      isCloseOnly: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    updateLiquidityPoolParameter(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateLiquidityPoolParameter(bytes32,int256)"(
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    updatePerpetualParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updatePerpetualParameter(uint256,bytes32,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    updatePerpetualRiskParameter(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updatePerpetualRiskParameter(uint256,bytes32,int256,int256,int256)"(
      perpetualIndex: BigNumberish,
      key: BytesLike,
      newValue: BigNumberish,
      minValue: BigNumberish,
      maxValue: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    withdraw(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "withdraw(uint256,address,int256)"(
      perpetualIndex: BigNumberish,
      trader: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
